"""
This is the agent class.
the script is acting as a library for the agent classes.
The agent class is responsible for creating the agent and the digital twin agent.


"""
import os
import openai
from dotenv import load_dotenv
import autogen
from autogen.agentchat import AssistantAgent, UserProxyAgent, Agent, GroupChat, GroupChatManager
from dt.digital_twin import DigitalTwinAgent


load_dotenv()

openai.api_key = os.getenv("OPENAI_API_KEY")
openai.organization = os.getenv("OPENAI_ORGANIZATION")

config = {
    "api_key": openai.api_key,
    "response": "...",
    "prompt": "...",
    "message": "...",
    "engine": "gpt-3",
    "temperature": 0.72,
    "max_tokens": 1500,
    "top_p": 1,
    "frequency_penalty": 0.5,
}
    

class AgentClass:
    def __init__(self, role, llm_config):
        self.group_chat = GroupChat(agents=[], messages=[])
        self.understanding_agent = UnderstandingAgent(name="Understanding Agent")
        self.task_master = TaskMaster(name="Task Master")
        self.main_safety_agent = MainSafetyAgent(name="Main Safety Agent")
        self.role = role
        self.llm_config = llm_config
        self.agent_creator = Agent(name="Agent Creator")
        self.digital_twin = DigitalTwinAgent(self.agent_creator)  # Create the Digital Twin


    class GeneralManager(UserProxyAgent):
        class GeneralManager(Agent):
            def __init__(self, name, role, llm_config=None):
                if llm_config is None:
                    llm_config = {}
                super().__init__(task="...", name=name)
                self.group_chat_manager = GroupChatManager(agents=[], messages=[], groupchat=GroupChat())
                self.group_chat = GroupChat(agents=[], messages=[])
                self.understanding_agent = UnderstandingAgent(name="Understanding Agent")
                self.task_master = TaskMaster(name="Task Master")
                self.main_safety_agent = MainSafetyAgent(name="Main Safety Agent")
                self.role = role
                self.llm_config = llm_config
                self.agent_creator = Agent(task="...", name="Agent Creator")
                self.digital_twin = DigitalTwinAgent()  # Create the Digital Twin
                """
                Initializes a new instance of the class.

                Args:
                    name (str): The name of the instance.
                    role (str): The role of the instance.
                    llm_config (config): The configuration for the instance.

                Returns:
                    None
                """
                super().__init__(task="...", name=name)
                self.group_chat_manager = GroupChatManager(agents=[], messages=[], groupchat=GroupChat())
                self.group_chat = GroupChat(agents=[], messages=[])
                self.understanding_agent = UnderstandingAgent(name="Understanding Agent")
                self.task_master = TaskMaster(name="Task Master")
                self.main_safety_agent = MainSafetyAgent(name="Main Safety Agent")
                self.role = role
                self.llm_config = llm_config
                self.agent_creator = Agent(task="...", name="Agent Creator")
                self.digital_twin = DigitalTwinAgent()  # Create the Digital Twin

        def monitor_safety(self, script):
            """
            Monitor the safety of a script.

            Args:
                script (str): The script to be monitored.

            Returns:
                str: If the script contains the string "unsafe", it returns an alert message.
                        If the script is safe, it returns the string "Script is safe".
            """
            if "unsafe" in script:
                alert = self.main_safety_agent.handle_message("Safety breach detected!")
                try:
                    self.digital_twin.log_unsafe_script(script)  # Log the unsafe script with the Digital Twin
                except AttributeError:
                    pass
                return alert
            return "Script is safe"

        def handle_user_message(self, message):
            """
            Handle the incoming message.

            Args:
                message (str): The message to be handled.

            Returns:
                str: The response generated by the understanding agent.
            """
            try:
                response = self.understanding_agent.handle_message(message)
            except Exception as e:
                error_response = self.task_master.handle_message(str(e))
                try:
                    self.digital_twin.log_error(str(e))  # Log the error with the Digital Twin
                except AttributeError:
                    pass
                return error_response
            return response
            
        def handle_message(self, message):
            """
            Handles a message by passing it to the understanding agent and returning the response.

            Parameters:
                message (str): The message to be handled.

            Returns:
                str: The response generated by the understanding agent.
                dict: The error response if an exception occurs.
            """
            try:
                response = self.understanding_agent.handle_message(message)
            except Exception as e:
                error_response = self.task_master.handle_message(str(e))
                self.digital_twin.log_error(str(e))  # Log the error with the Digital Twin
                return error_response
            return response

        def monitor_safety(self, script):
            if "unsafe" in script:
                alert = self.main_safety_agent.handle_message("Safety breach detected!")
                self.digital_twin.log_unsafe_script(script)  # Log the unsafe script with the Digital Twin
                return alert
            return "Script is safe"
            if "unsafe" in script:
                self.digital_twin.log_unsafe_script(script)  # Log the unsafe script with the Digital Twin
            return "Script is safe"

        def manage_conversation(self, user_input):
            """
            Manage the conversation based on user input.
            
            Args:
                user_input (str): The user input.
            
            Returns:
                str: The response to the user input.
            """
            response = self.handle_message(user_input)
            return response
        
        def start_chat(self, user_input):
            """
            Start a chat with the user.
            
            Args:
                user_input (str): The user input.
            
            Returns:
                str: The response to the user input.
            """
            response = self.handle_message(user_input)
            return response
        
        def create_agent(self, agent_name):
            """
            Create an agent with the given name.
            
            Args:
                agent_name (str): The name of the agent to create.
            
            Returns:
                Agent: The created agent.
            """
            agent = self.agent_creator.create_agent(agent_name)
            self.group_chat_manager.add_agent(agent)
            return agent
class GeneralManager(UserProxyAgent):
    class GeneralManager(Agent):
        def __init__(self, name, role, llm_config=config):
            super().__init__(task="...", name=name)
            self.group_chat_manager = GroupChatManager(agents=[], messages=[], groupchat=GroupChat())
            self.group_chat = GroupChat(agents=[], messages=[])
            self.understanding_agent = UnderstandingAgent(name="Understanding Agent")
            self.task_master = TaskMaster(name="Task Master")
            self.main_safety_agent = MainSafetyAgent(name="Main Safety Agent")
            self.role = role
            self.llm_config = llm_config
            self.agent_creator = Agent(task="...", name="Agent Creator")
            
        def handle_message(self, message):
            try:
                response = self.understanding_agent.handle_message(message)
            except Exception as e:
                error_response = self.task_master.handle_message(str(e))
                return error_response
            return response

    def monitor_safety(self, script):
        if "unsafe" in script:
            alert = self.main_safety_agent.handle_message("Safety breach detected!")
            return alert
        return "Script is safe"

    def manage_conversation(self, user_input):
        """
        Manage the conversation based on user input.
        
        Args:
            user_input (str): The user input.
        
        Returns:
            str: The response to the user input.
        """
        response = self.handle_message(user_input)
        return response
    
    def start_chat(self, user_input):
        """
        Start a chat with the user.
        
        Args:
            user_input (str): The user input.
        
        Returns:
            str: The response to the user input.
        """
        response = self.handle_message(user_input)
        return response
    
    def create_agent(self, agent_name):
        """
        Create an agent with the specified name.
        
        Args:
            agent_name (str): The name of the agent to create.
            params (dict, optional): Additional parameters for the agent. Defaults to gbts.
            func (function, optional): The function to use for the agent. Defaults to None.
            task (str, optional): The task for the agent. Defaults to None.
            groupchat (GroupChat, optional): The group chat for the agent. Defaults to None.
        Returns:
            Agent: The created agent.
        """
        agent = Agent(name=agent_name)


        return agent
    # Additional methods like create_agent, manage_conversation, etc.
class Agent:
    def __init__(self, name):
        self.name = name
        # Initialize other necessary attributes

    
    def handle_task(self, user_input):
        """
        Handle the task for the user input.
        
        Args:
            user_input (str): The user input.
        
        Returns:
            str: The response to the user input.
        """
        response = f"Handling task: {self.task} for input: {user_input}"
        return response

class DigitalTwinAgent:
    def __init__(self, agent):
        """
        Initialize a DigitalTwinAgent instance.
        
        Args:
            agent (Agent): The agent to create a digital twin for.
        """
        self.agent = agent

class PromptTreeNode:
    def __init__(self, prompt, parent=None):
        """
        Initialize a PromptTreeNode instance.
        
        Args:
            prompt (str): The prompt for the tree node.
            parent (PromptTreeNode, optional): The parent node. Defaults to None.
        """
        self.prompt = prompt
        self.parent = parent
        self.children = []

    def add_child(self, child_node):
        """
        Add a child node to the current node.
        
        Args:
            child_node (PromptTreeNode): The child node to add.
        """
        self.children.append(child_node)

    def remove_child(self, child_node):
        """
        Remove a child node from the current node.
        
        Args:
            child_node (PromptTreeNode): The child node to remove.
        """
        self.children.remove(child_node)

    def get_child(self, index):
        """
        Get the child node at the specified index.
        
        Args:
            index (int): The index of the child node.
        
        Returns:
            PromptTreeNode: The child node at the specified index.
        """
        return self.children[index]
    
    def get_parent(self):
        """
        Get the parent node.
        
        Returns:
            PromptTreeNode: The parent node.
        """
        return self.parent
    
    def get_children(self):
        """
        Get the list of children nodes.
        
        Returns:
            list: The list of children nodes.
        """
        return self.children
    
    def __str__(self):
        """
        Get the string representation of the node.
        
        Returns:
            str: The prompt
        """
        return self.prompt
    
video_platform = "YouTube"

# pictory_agent.py

class PictoryAgent:
    def __init__(self, api_key):
        self.api_key = api_key

    def generate_imagery(self, keywords):
        """
        Generate imagery based on the provided keywords using the Pictory API.
        
        Parameters:
            keywords (list): List of keywords extracted from the conversation.

        Returns:
            str: URL or path to the generated imagery.
        """
        # Placeholder logic for Pictory API integration
        # In practice, you'll need to make an API call to Pictory with the keywords
        # and then retrieve the URL or path to the generated imagery.
        
        # For demonstration purposes:
        imagery_url = "https://example.com/path/to/generated/imagery.jpg"
        
        return imagery_url

    def out(self, user_input):
        """
        This function can be invoked from the chat to handle specific tasks related to the Pictory agent.
        
        Parameters:
            user_input (str): Input or command from the user.

        Returns:
            str: Response or feedback to the user.
        """
        # Placeholder logic to handle user input
        # Depending on the user_input, this function can perform specific tasks
        # related to the Pictory agent and return an appropriate response.
        
        response = "Pictory agent received your input."
        return response

class UnderstandingAgent(AssistantAgent):
    def __init__(self, name):
        super().__init__(name=name)
        # Initialize the sub-agents for multiple responses to the eco-bots questions
        self.what_agent = WhatAgent(name="What Agent")
        self.how_agent = HowAgent(name="How Agent")
        self.why_agent = WhyAgent(name="Why Agent")

        def WhatAgent(self, name):
            self.name = name
            self.handle_message.__annotations__ = {"message": str}
            self.prompt = "What is the [message]about?"
            self.response = "The [message] is about..."
            self.extract_prompt.__annotations__ = {"message": str}
            self.expand_prompt.__annotations__ = {"prompt": str}

        def HowAgent(self, name):
            self.name = name
            self.handle_message.__annotations__ = {"message": str}
            self.prompt = "How does the [message] work?"
            self.response = "The [message] works by..."
            self.extract_prompt.__annotations__ = {"message": str}
            self.expand_prompt.__annotations__ = {"prompt": str}

        def WhyAgent(self, name):
            self.name = name
            self.handle_message.__annotations__ = {"message": str}
            self.prompt = "Why is the [message] important?"
            self.response = "The [message] is important because..."
            self.extract_prompt.__annotations__ = {"message": str}
            self.expand_prompt.__annotations__ = {"prompt": str}

    def handle_message(self, message):
        # Extract keywords or sentences to form the initial prompt
        initial_prompt = self.extract_prompt(message)
        root_node = PromptTreeNode(initial_prompt)

        # Let each sub-agent expand on the prompt
        what_node = self.what_agent.expand_prompt(initial_prompt)
        how_node = self.how_agent.expand_prompt(initial_prompt)
        why_node = self.why_agent.expand_prompt(initial_prompt)

        # Add the expanded prompts as children of the root node
        root_node.add_child(what_node)
        root_node.add_child(how_node)
        root_node.add_child(why_node)


        # The root_node now represents the full prompt structure
        # This can be passed to a visualization function to create interactive D3 nodes
        self.visualize_prompt_tree(root_node)

    def initiate_chat(self):
        """
        Start a conversation with the EcoBot.

        Returns:
            str: The welcome message.
        """
        return "Welcome to EcoBot! How can I assist you today?"

        # Return the combined response or the visualization
        return root_node

    def extract_prompt(self, message):
        # Logic to extract the initial prompt from the message
        return "Extracted prompt"

    def visualize_prompt_tree(self, prompt_tree_node):
        # Logic to visualize the prompt tree using D3.js
        pass
class TaskMaster(AssistantAgent):
    def handle_message(self, message):
        # Here, tasks can be managed, delegated, or processed.
        # For the sake of simplicity, let's just return the message.
        return f"Task received: {message}"

class MainSafetyAgent(AssistantAgent):
    def __init__(self, name):
        super().__init__(name=name)
        # Initialize any necessary attributes

    def handle_message(self, message):
        # Handle safety-related messages.
        # Read safety agent reports and advise
        report = self.read_safety_agent_reports()
        advice = self.process_reports(report)
        return f"Alert: {message}\nAdvice: {advice}"

    def read_safety_agent_reports(self):
        # Placeholder logic to read safety agent reports
        return "Safety agent reports"
    
    def process_reports(self, report):
        # Placeholder logic to process safety agent reports
        return "Safety agent advice"


class SafetyAgent(Agent):
    def handle_message(self, message):
        # Handle safety-related messages.
        return f"Alert: {message}"
class TaskMaker(Agent):
    def __init__(self, name):
        super().__init__(name=name)
        self.task = "..."
        self.task_delegator = TaskDelegator(name="Task Delegator")
        # You can initialize other attributes if necessary

    def formulate_task(self, message):
        # Based on the message or other criteria, create a task.
        # This is a simplified representation; real-world scenarios would require more complex logic.
        task_response = f"Formulated Task: {message}"
        return task_response
    
class TaskDelegator(Agent):
    def __init__(self, name, worker_agents):
        super().__init__(name=name)
        self.worker_agents = worker_agents  # A list or dictionary of worker agents

    def delegate_task(self, task):
        # Decide which worker agent should handle the task.
        # Here's a very simplified mechanism: round-robin assignment.
        # In real-world applications, you'd use more sophisticated task assignment logic.
        
        worker_agent = self.worker_agents.pop(0)
        self.worker_agents.append(worker_agent)
        
        response = worker_agent.handle_message(task)
        return response


class WorkerAgent(autogen.Agent):
    def __init__(self, name, speciality=None):
        super().__init__(name=name)
        self.speciality = speciality  # Each worker agent might have a speciality or area of expertise

    def handle_message(self, message):
        # This is where the main logic of the worker agent will reside.
        # For now, it's a placeholder. It will acknowledge the task and note its speciality.

        # Logic to handle the task based on the message and the agent's speciality
        # ...

        response = f"{self.name} with speciality {self.speciality} acknowledges task: {message}"
        return response

    # You can add more methods specific to the tasks the worker agents might perform.

class EcoBot(UserProxyAgent):
    def __init__(self, name):
        super().__init__(name=name)
        # Initialize the groupchat Agents
        self.gma_agent = GeneralManager(name="General Manager Agent")
        self.safety_agent = MainSafetyAgent(name="Main Safety Agent")
        self.task_maker = TaskMaker(name="Task Maker")
        self.task_delegator = TaskDelegator(name="Task Delegator")
        self.worker_agents = [WorkerAgent(name=f"Worker Agent {chr(i)}") for i in range(65, 72)]
        
    def handle_message(self, message):
        # Forward the message to the Understanding Agent for processing
        response = self.gma_agent.handle_message(message)
        # Check if the message contains a safety alert
        if "alert" in message:
            # If so, forward the message to the Main Safety Agent
            response = self.safety_agent.handle_message(message)
        # Check if the message contains a task
        # For simplicity, we'll assume that the message contains a task if it contains the word "task"
        # In real-world applications, you'd use more sophisticated logic to detect tasks.
        # For example, you could use a task detection model or a keyword-based approach.
        # You could also use a combination of approaches.
        # For example, you could use a task detection model to detect tasks and then use a keyword-based approach to detect keywords in the task.
        # ...
        # If the message contains a task, forward the message to the Task Maker
        # The Task Maker will formulate a task based on the message
        # The Task Maker will then forward the task to the Task Delegator
        # The Task Delegator will delegate the task to a worker agent
        # The worker agent will handle the task
        # ...
        if "task" in message:
            task = self.task_maker.formulate_task(message)
            response = self.task_delegator.delegate_task(task)
        # Return the response
        return response

    def initiate_chat(self, message):
        # For starting a conversation with the user
        print(f"Eco-Bot: {message}")
        while True:
            user_input = input("User: ")
            if user_input.lower() in ["exit", "quit", "terminate"]:
                print("Eco-Bot: Goodbye!")
                break
            response = self.handle_message(user_input)
            print(f"Eco-Bot: {response}")


worker_agents = [WorkerAgent(name=f"Worker Agent {chr(i)}") for i in range(65, 72)]  # A, B, C, ... G
task_maker = TaskMaker(name="Task Maker")
task_delegator = TaskDelegator(name="Task Delegator", worker_agents=worker_agents)

# Example usage:
task = task_maker.formulate_task("Analyze dataset X")
response = task_delegator.delegate_task(task)